class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        """
        0 -> 0
        0 -> 1
        1 -> 0
        1 -> 1
        2 -> 2
        
        2 -> 3 -> 1 -> 
        
                    => 2
            => 1    => 3
        0 
        
        300 ** 2 
        
        not union find though, I can do a dfs solution, with the dfs counting the number of visited nodes for me.
        
        
        for every node in initial we will do dfs(others in initial) and then have a final cost
        """
        
        
        def dfs(node, visited):
            for neighbour, edge in enumerate(graph[node]):
                if edge and neighbour not in visited:
                    visited.add(neighbour)
                    dfs(neighbour, visited)
        
        min_malware = [inf, 0]
        for removed_node in initial:
            infected = set([])
            for current_node in initial:
                if current_node not in infected and current_node != removed_node:
                    infected.add(current_node)
                    dfs(current_node, infected)
                    
            min_malware = min(min_malware, [len(infected), removed_node])
            
        return min_malware[-1]
            
                    